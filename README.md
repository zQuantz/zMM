# Market Making

Please read this before looking at any of the code. Each script is important.

## Meta Parameters

The meta parameter TICK_LIMIT is found in the const.py file and is used throughout the code. It controls the maximum tick change allowed from period to period as well as the size of the state space and the size of the action space at each step. I suggest leaving it to 4 to reproduce the results of my report. Other meta parameters are found in the dp.py script.

## Data Processing

To preprocess the data and calculate the co-occurrence matrix, run

```bash
python transform.py
python lag_1_cooccurrence.py
```

The files ibm_t.csv and cooccurrence_matrix.csv should appear in the data/ directory.

## Dynamic Programming Objects

All mathematical objects required by any dynamic programming solution are found in the dp.py file. The individual algorithms import methods and values from this script.
Note that I override the print function to avoid overflowing the console with text. This can be commented out if one wants to see the step by step process.

## Back Recursion

This can be ran via
```bash
python back_recursion.py 50
```

The mandatory parameter "50" refers to the horizon the market maker optimizes over. This script calculates the optimal dynamic programming solution using back recursion and saves the cost-to-go (J) and action (U) objects to the back_recursion/ directory. This directory should be further subdivided by the horizon parameter specified above.

## Rollout

Since rollout is an online algorithm, the path_generator.py script needs to be run first.

### Path Generator

This script generates 10,000 randomly samples paths by using the co-occurrence matrix calculated above. 6 of these paths are chosen as exemplars to benchmark each algorithm that is implemented. As usual, they are saved to the paths/ directory and are subdivided by the horizons 50, 100 and 200. The 6 chosen path names are uptrend, downtrend, no_change, high_vol, low_vol and avg_vol. 

### Rollout Script

After running

```bash
python path_generator.py
```

the rollout.py script is ready for execution. An example call is

```bash
python rollout.py 50 uptrend
```
which refers to optimizing over the 50 period uptrend path. A dictionary is saved to the rollout/ directory subdivided by the horizon chosen. The items in the dictionary are the states, actions and rewards the algorithm produced as a final solution. One can tweak the number of recursion steps the algorithm uses to estimate the cost-to-go function by changing
```python
if k == 2
```
to
```python
if k == my_choice_here
```
in the
```python
deeper(state, totalcost, weight, k)
```
function. I do warn that any number > 2 takes a considerable amount of time.

## Parametric Approximation

Yet another method that relies on more than 1 script. Since parametric approximation requires a monte carlo step of sampling states, I split this algorithm in two steps.

### Monte Carlo Sampler

run python state_generator.py to yield a dictionary of states per stage that is saved to the states/ directory. This is computed by random sampling of the actions and moving
through many sample paths that we previously generator. When all is finished, we have a distribution of states per stage that can be used to train the parametric cost-to-go function.

### Parametric Approximation Script

By running "python linear_parametric_approximation.py 50", one linear model is learned for each 50 stages that is specified by the "50" parameter. The monte carlo sampler samples up until
stage 201. If your parameter exceeds a value of 200, the parameter would also have to be changed in the monte carlo sampler.

## timers/ Directory

This directory holds a single file called timer_dict.pkl. After each model is computed, the computation time is saved to the dictionary for later use. I would suggest looking at this
file if you are planning on running any of these. Some take longer than others. All files that are saved can be opened with the joblib python package.

```python
with open('my/file/here', 'rb') as file:
     my_object = joblib.load(file)
``` 

## Visualizing a Policy

Once a model is computed a saved, the animation.py script converts the policy generated by the model into a small movie. An example call is "python animation.py 50 uptrend rollout" to denote 
we want a horizon 50 rollout to be displayed over the uptrend path. The video generated is saved in the policies/ directory. Reading the paper will greatly help in understanding the video,
however, I offer some explanation here.

### Plot #1 (Top left): Price Series

This plot shows the market makers decision about where its bid and ask orders are. The bid is the green horizontal line and the ask is the red horizontal line. These lines represent the current
decision only and do not reflect any historical decisions for these actions. The black line is the price series of the simulated path. IF the black line meets or exceeds any of the other lines,
a transaction occurs. Given the nature of that transaction, an x is annotated to document where the purchases have taken place.

### Plot #2 (Top right): Net Position

This plot is simply the position held by the market maker. If the market maker has a bid order executed, this plot will increase by one. The inverse is true for ask orders.

### Plot #3 (Bottom left): Cummulative Revenue

This plot shows the cummulative revenue of the market maker throughout the instance. The more green, the better it is doing.

### Plot #4 (Bottom right): Unrealized Profit or Loss

This plot shows the current gain or loss that the market maker is holding based on the time and nature of each transaction. A large negative unrealized loss is not a good sign in this context.

## Analying each Algorithm



