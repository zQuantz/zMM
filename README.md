# Market Making

Please read this before looking at any of the code. Each script is important.

## Meta Parameters

The meta parameter TICK_LIMIT is found in the const.py file and is used throughout the code. It controls the maximum tick change allowed from period to period as well as the size of the state space and the size of the action space at each step. I suggest leaving it to 4 to reproduce the results of my report. Other meta parameters are found in the dp.py script.

## Data Processing

To preprocess the data and calculate the co-occurrence matrix, run

```bash
python transform.py
python lag_1_cooccurrence.py
```

The files ibm_t.csv and cooccurrence_matrix.csv should appear in the data/ directory.

## Dynamic Programming Objects

All mathematical objects required by any dynamic programming solution are found in the dp.py file. The individual algorithms import methods and values from this script.
Note that I override the print function to avoid overflowing the console with text. This can be commented out if one wants to see the step by step process.

## Back Recursion

This can be ran via
```bash
python back_recursion.py 50
```

The mandatory parameter "50" refers to the horizon the market maker optimizes over. This script calculates the optimal dynamic programming solution using back recursion and saves the cost-to-go (J) and action (U) objects to the back_recursion/ directory. This directory should be further subdivided by the horizon parameter specified above.

## Rollout

Since rollout is an online algorithm, the path_generator.py script needs to be run first.

### Path Generator

This script generates 10,000 randomly samples paths by using the co-occurrence matrix calculated above. 6 of these paths are chosen as exemplars to benchmark each algorithm that is implemented. As usual, they are saved to the paths/ directory and are subdivided by the horizons 50, 100 and 200. The 6 chosen path names are uptrend, downtrend, no_change, high_vol, low_vol and avg_vol. 

### Rollout Script

After running

```bash
python path_generator.py
```

the rollout.py script is ready for execution. An example call is

```bash
python rollout.py 50 uptrend
```
which refers to optimizing over the 50 period uptrend path. A dictionary is saved to the rollout/ directory subdivided by the horizon chosen. The items in the dictionary are the states, actions and rewards the algorithm produced as a final solution. One can tweak the number of recursion steps the algorithm uses to estimate the cost-to-go function by changing
```python
if k == 2
```
to
```python
if k == my_choice_here
```
in the
```python
deeper(state, totalcost, weight, k)
```
function. I do warn that any number > 2 takes a considerable amount of time.

## Parametric Approximation

Yet another method that relies on more than 1 script. Since parametric approximation requires a monte carlo step of sampling states, I split this algorithm in two steps.

### Monte Carlo Sampler

run
```bash
python state_generator.py
```
to yield a dictionary of states per stage that is saved to the states/ directory. The states are generated by a random walk through the paths we previously generated.

### Parametric Approximation Script
By running
```bash
python linear_parametric_approximation.py 50
```
one linear model is learned per stage of the horizon (the horizon length is specified as 50 in the example). The linear models are learned backwards to approximate the cost-to-go functions. The monte carlo sampler in the previous step generates states up to horizon 201. One would need to change this if a horizon > 200 is desired.

## timers/ Directory

This directory contains a single file named ticker_dict.pkl. This file holds the statistics on computation time for each model. I suggest using this file to align your expectations for how long each of these models take to compute. Any of the files in this project that end in "pkl" are opened with the joblib python package.

```python
with open('my/file/here', 'rb') as file:
     my_object = joblib.load(file)
```

## Visualizing a Policy

Once a model is computed a saved, the animator.py script converts the model generated policy into a small movie.

```bash
python animation.py 50 uptrend rollout
```
generates a 50 horizon uptrend policy to be shown with the rollout algorithm. The video is saved in the policies/ directory with the following naming convention: horizon_pathname_algorithm.mp4. Reading the paper will allow for a deeper understanding of the policies and how to interpret them, however, I offer some explanation here.

#### Plot #1 (Top left): Price Series

This plots shows the market maker's decisions as well as the change in price from period to period. The bid price chosen by the market maker is shown as a green horizontal line. The ask price chosen by the market maker is shown as a red horizontal line. These lines represent the current decision and have no historical component factored in the visuals.

The black line is the current and historical price. This is calcualted as the cummulative sum of price jumps given the specified path.

Any time a transaction occurs, an "x" is annotated above the black line. The color indicates whether the transaction was a buy or a sale.

#### Plot #2 (Top right): Net Position

This plot is simply the position held by the market maker. If the market maker has a bid order executed, this plot will increase by one. The inverse is true for ask orders.

#### Plot #3 (Bottom left): Cummulative Revenue

This plot shows the cummulative revenue of the market maker throughout the instance. The more green, the better it is doing.

#### Plot #4 (Bottom right): Unrealized Profit or Loss

This plot shows the current gain or loss that the market maker is holding based on the time and nature of each transaction. A large negative unrealized loss is not desired.

## Analyzing each Algorithm

If all scripts were ran successfully, simply run

```bash
python analysis.py
```

This script generates csv files with descriptive statistics about each algorithm's performance on each of the paths and horizons. The files are found in the algorithm's respective folder under the results/ subdirectory (back_recursion/results/200.csv for example).



